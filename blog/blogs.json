{
    "blogs": [
         {
            "author": "Kirt Gittens",
            "shortname": "the-evil-parts",
            "title": "Javascript: Navigating the Evil Parts",
            "date": "10/12/15",
            "post": "<br>\n                    <div class = \"blog-post\">\n                        <p>\n                        We've complained about javascript before, and you might have been able to dismiss those complaints as pseudointellectual ramblings about the inconveniences of a language we didn't really understand, and you might have been right. But Javascript and us have been getting coffee on a daily basis for the past few months and now we're absolutely certain, that we hate its guts, and have a legitimate case for it's immediate and crushing condemnation.\n                            </p>\n                        \n                        <br>\n\n<h4>Objects.</h4>\n<br>\n<p>\n\t<b>Javascript objects are fundementally dishonest.</b> And the reasons aren't immediately clear, they're half way between most languages maps/dictionaries (in syntax and representation) and legitimate first class objects. The trouble comes from the former set of assumptions, Javascript objects look like dictionaries, and behave like them in most respects, but treating them as such will lead to some confusing behavior. \n</p>\n                        <br>\n                        \n    <h4>\n\tJavascript Objects vs Python Dicts\n    </h4>\n                        <br>\n\t<b>Javascript:</b>\n<pre><code class = \"javascript\">\n\t\tvar x = {}\n\t\tx['key'] = 21\n\n\t\t// x['key'] is now 21\n\n\t\tconsole.log(x['key']) // \"prints\" 21\n</code>\n</pre>\n                        <br>\n                        \n\t<b>Python:</b>\n<pre>\n    <code class =\"python\">\n        x = {}\n        x['key'] = 21\n\n        print x['key'] # also prints 21, same thing, correct?\n    </code>\n</pre>\n                        <br>\n    <p>\n\tI choose python because it's fairly easy to read even if you're not heavily farmilliar with it, but similar syntax exists in an abundance of langagues for dealing with *maps*, and this is where the confusion starts. These data structures syntactically behave like a structure they are not. This becomes apparent when you want to do ANY NORMAL dictionary operation on a JS object.\n</p>\n                        <br>\n                        <p>\n \tLet's compare the way that objects work, to the way that an almost identical syntax works in python.\n</p>\n    <br>\n<b>Python:</b>\n<pre><code class = \"python\">\n\t\n\t\tobj = {}\n\t\tobj['key'] = 100\n\n\t\t'key' in obj # True, makes sense right?\n\n\t\tarr = [obj]\n\t\tobj in arr # this is also True, and this is obvious\n        </code>\n</pre>\n                        <br>\n<p>here comes the evil part</p>\n    <br>\n<b>Javascript</b>\n<pre>\n<code class=\"javascript\">\n\tvar obj = {}\n\tobj['key'] = 100\n\n\t'key' in obj // true, and this makes sense, right? \n\n\tvar arr = [obj]\n\n\tobj in arr // THIS IS FALSE??? MAKES NO SENSE AT ALL\n</code>\n</pre>\n<br>\n                        \n<p>\nThis makes no sense! Our object is clearly in the array. Looking at problems of object equality shows a further gap in the functionality.\n</p>\n                        \n<br>\n<h4>\n\tHow do you know if two objects (or dicts) are equal?\n</h4>\n                        <br>\n\n\t<b>Python:</b>\n                        <br>\n    <pre><code class =\"python\">\n\ta = {\"key\": 100}\n\tb = {\"key\": 100}\n\n\tprint a == b // True, and this makes sense\n    </code>\n    </pre>\n<br>\n\t<b>Javascript:</b>\n    <pre>\n    <code class = \"javascript\">\n\tvar a = {\"key\": 100}\n\tvar b = {\"key\": 100}\n\n\tconsole.log(a == b) // false\n \tconsole.log(a === b) //  WHAT????\n    </code>\n</pre>\n<br>\n                        \n                        <p>\n \tAgain, we have a syntax that most of us are used to, doing something that makes most of our stomachs turn. Making your language or API expose farmiliar details to the developer isn't mandatory, but it makes the developer less likely to pull his or her hair out on any given day. The real reason why this happens, is that you're essentially comparing pointer equality rather than value equality when you use equals in Javascript (if you care about python, it'd be like comparing two dicts with a is b instead of a == b). The actual algorithm details can be found in the ECMAScript specification if you want to answer the why question in a bit more depth.\n</p>\n\n                        \n                        <br>\n \tAs for solving this problem:\n    <h4>\n \t<a href=\"https://lodash.com/docs#isEqual\">Lodash</a>\n        </h4>\n            <br><small>(please don't mention underscore.js, it's a sensitive topic)</small>\n                        \n                        <br>\n                        <p>\n                        is a promising JS library that provides us a few really helpful functions for dealing with issues like this\n                        </p>\n                        <br>\n\n \t<pre> <code class=\"javascript\">_.isEqual()\n    </code>\n\n</pre>\n                        <br>\n                        <p>\n \tThis function from lodash, will ACTUALLY allow us to compare two objects, in a way that makes sense to all of us intuitively. \n</p>\n                        <br>\n\n\n\n<p>\n \tMore on the perils of the Javascript hiding in your basement at 9. \n\n</p>",
            "img_link":"../img/img10.png"
        },
        {
            "author": "Kirt Gittens",
            "post": "<br>\n                        <p>\nWhen you review enough code, you start to see things. Terrifying things. The things that developers attempt to sneak by the gatekeeping duties of the code reviewer. These are the reasons why we have standards, so that before you commit a code atrocity (whether that be something like writing the nefarious line of code that is if len(array) > 0: or something as simple as forgetting to write documentation for a complicated function) standards offer you an opportunity to be slapped in the face before the atrocious mistake you've made makes it into a PR, or even worse, a master branch somewhere.</p>\n                        <br>\n                        <p>\nEveryone's got their own offcial standards of code quality that are specific to the language they use, (we have PEP8 over here in Python), but you can still commit a cardinal sin even if you follow the standards to the letter. This is where I like to invoke the wisdom of Tim Peters, and apply the knowledge he has imparted to us in the Zen of Python (you know it already, at least, you'd better. import this).\n                        </p>\n                        <br>\n                        <p>\nI've seen a few things recently that we do all the time, and they aren't exactly breaking PEP8 code standards, but still just generally make the code more difficult to understand. The thing that makes python great is readability, so making your code less readable for any purpose is a (at the least) suspicious move.\n                            </p>\n                        <br>\n                        <p>\nLet's review some code, shall we?\n                        </p>\n                        <br>\n                            <br>\n<blockquote>1. Readability Counts (even if it might require a bit more code)</blockquote>    \n<br>\n                        <pre><code class =\"python\">\nnew_strings = [int(thing.split(\"-\")[0])  - int(thing2.split(\"-\")[0]) for thing1, thing2 in somedict.items() if \"_parse_key\" in somedict]\n</code>\n                        </pre>\n<br>\n<br>\n<p>\nList comprehensions are great ways to compose simple operations to populate an array with necessary values. No problems with using them, but I think after a certain point, if you try and combine too many operations, you might have less code (in terms of lines), but It'll be way more difficult to understand every you have to look at it, and explain to someone else what it's doing. I've seen comprehensions longer than this, and sure, they were at most 1,2 lines, but It gets pretty difficult to understand what the hell is going on in a meaningful way fairly quickly. Don't sacrifice readability and cleanliness for fewer lines of code.</p>\n                        <br>\n                        <br>\n                        <pre>\n<code class = \"python\">                   \nnew_strings = []\nfor thing1, thing2 in somedict.items():\n\n\tif \"_parse_key\" in somedict:\n\n\t\t# get a first number from the input\n\t\tnum1 = int(thing.split(\"-\")[0])\n\t\tnum2 = int(thing2.split(\"0\")[0])\n\t\t\n\t\t# subtract the result\n\t\tnew_strings.append(num1-num2)\n</code>\n</pre>\n                        <br>\n                        <br>\n                        <blockquote>2. Errors should never pass silently (NOT EVEN ONCE)</blockquote>\n                        <p> A lot of times, I've been forced to code things that break this rule due to buisness requirements, but if you have the freedom to make such a decision, don't let your application keep going when something atrocious happens. dict.get or getattr, are both tools that end up getting used to silence errors (and not that they're ever invalid solutions, but there's cases where they're used to continue the workflow when your application is missing data that it needs), instead of actually throwing a KeyError or AttributeError, we use one of these methods, and suppress the issue by returning None, or simply having our functions do nothing or ignore the apparent issue. There's a valid philosophy of never wanting to interrupt the user experience (and there's a whole other conversation that we can dive into about how present these kinds of issues to the user), but from a pure code perspective, doing this makes debugging nearly impossible. If you suppress the actual code issues, when deeper problems appear, doing a root cause analysis becomes difficult, and finding the real issue become nearly impossible.\n                        </p>"
,
            "date": "10/12/15",
            "shortname": "zen-python",
            "title": "The Zen of Python: In Practice",
            "img_link": "../img/img5.png"
        },
        {
            "author": "Kirt Gittens",
            "post": "<blockquote>\nDo you like C? Are you scared to write actual C? Well then do I have something to tell you about!\n</blockquote>\n                        <br>\n                        <br>\n                        <p>\nHere at damage control, there seems to be hours of never ending debate about what language and frameworks to use for the development of our next product, (as there should be anywhere you get a bunch of developers in one place), and the recent discovery of golang has help extend that fruitless argument for a substantial number of hours.\n                            </p>\n                        <br>\n                        <p>\nGoogle's golang is a relatively new statically typed, and compiled language that's recently been taking developers by storm, and for good reason.It's headed up by some of the CS greats (Rob Pike, and Ken Thompson are involved in it's design), and for the most part, has almost no learning curve. If you're used to any languages in the same category you can probably pick it up in a day or two. Go feels really minimalistic in its design, in all of the ways that make C appealing, but comes with a modern standard library and that definitely helps kickstart your ideas. In many ways its exactly what a certain subset of us have been looking for.\n                        </p>\n                        <br>\n                        <blockquote>\n                        So, Should you use it?\n                        </blockquote>\n                        <br>\n                        <p>\nIt might not be for everyone, but we can offer some reasons why you might want to.\n                        </p>\n                        <br>\n                            <br>\n<blockquote>It's like C, but for Mere Mortals</blockquote>    \n<p>\nGo feels really farmilliar to us as former C developers, but without a lot of the memory management nightmares that have kept C out of the modern language conversation in recent years. (yes there is garbage collection, no I will not start a fight with you about it, yes there's a valid conversation to be had there). Go is strongly typed, but there's type inference, which makes it feel a lot friendlier to people coming from modern languages. \n</p>\n<br>\n                        <pre class =\"brocode\">\n                        // in golang stuff like\n\n                        var mystring := \"string without type declaration\"\n                        var myint = 233 // int declared without int myint\n\n                        // JUST WORKS\n                        </pre>\n<br>\n<br>\n                        <blockquote>Batteries Included</blockquote>\n                        <p>\n    \nGo feels minimalistic, but at the same time, maintains all of the essentials necessary for your average tasks in the standard library out of the box. There's no object oriented programming (structures in Go seems to feel much more like objects, since you can now define functions on structs without a lot of function pointer magic). Without needing any external frameworks or packages, we were able to get our web application off the ground, using the packages included with the go distribution, and in comparison to the other languages of a similar structure and type, Go's standard library feels much more developed (while it might shirk the minimalism requirements of C, the value that's provided is endless). You get predefined data types that just aren't present in C, things like slices and maps, which are essentially python lists and dictionaries, <br><br><small>(and hey, MAPS ARE A BUILT IN TYPE, YOU DONT NEED TO READ A PAPER ON SIMPLE UNIFORM HASHING ASSUMPTIONS TO GET PYTHON DICT STYLE KEY VALUE PAIRS)</small><br><br>\n                        </p>\n                        <br>\n                        <blockquote>But there's also one really aggravating thing that's made development difficult\n</blockquote>\n                        <br>\n                        <p>\n                        In python, modules are simple individual source files, and packages are collections of those files.\n\tYou can have as many pacakges and modules in whatever directory structure you want, so long as they're \n\taccessible from the file you need them in. This is important because it means there's essentially no \"enforced\" directory structure, other than the basic way that you choose to nest your files within modules. You maintain complete control over the organization of your code by default. In Go, this is not the case.\n                        </p>\n                        <br>\n                        <p>\n\tBecause of the way \"packages\" work in go, you can't just write code in another file (like headers in C, or modules in python), and have it accessible from your main program, which makes the organization of your code take a little bit more work. Coming from Python or C, your knoweldge about headers and modules is of little use here, and including a bit of Go code from another file, can't be done without the proper workspace configuration, and environment setup (packages are not equivalent to python's modules or C's headers), and if you want to use a different directory structure than what go has in mind, you may run into some issues with the setup. \n                        </p>\n                        <br>\n                        <p>\nThese observations are coming from fairly early into usage of the language, (as well as being relatively early into the devlopment of the language itself), but so far Go feels like it's the powerful tool we've been waiting for.\n                        </p>\"<blockquote>\\nDo you like C? Are you scared to write actual C? Well then do I have something to tell you about!\\n</blockquote>\\n                        <br>\\n                        <br>\\n                        <p>\\nHere at damage control, there seems to be hours of never ending debate about what language and frameworks to use for the development of our next product, (as there should be anywhere you get a bunch of developers in one place), and the recent discovery of golang has help extend that fruitless argument for a substantial number of hours.\\n                            </p>\\n                        <br>\\n                        <p>\\nGoogle's golang is a relatively new statically typed, and compiled language that's recently been taking developers by storm, and for good reason.It's headed up by some of the CS greats (Rob Pike, and Ken Thompson are involved in it's design), and for the most part, has almost no learning curve. If you're used to any languages in the same category you can probably pick it up in a day or two. Go feels really minimalistic in its design, in all of the ways that make C appealing, but comes with a modern standard library and that definitely helps kickstart your ideas. In many ways its exactly what a certain subset of us have been looking for.\\n                        </p>\\n                        <br>\\n                        <blockquote>\\n                        So, Should you use it?\\n                        </blockquote>\\n                        <br>\\n                        <p>\\nIt might not be for everyone, but we can offer some reasons why you might want to.\\n                        </p>\\n                        <br>\\n                            <br>\\n<blockquote>It's like C, but for Mere Mortals</blockquote>    \\n<p>\\nGo feels really farmilliar to us as former C developers, but without a lot of the memory management nightmares that have kept C out of the modern language conversation in recent years. (yes there is garbage collection, no I will not start a fight with you about it, yes there's a valid conversation to be had there). Go is strongly typed, but there's type inference, which makes it feel a lot friendlier to people coming from modern languages. \\n</p>\\n<br>\\n                        <pre class =\\\"brocode\\\">\\n                        // in golang stuff like\\n\\n                        var mystring := \\\"string without type declaration\\\"\\n                        var myint = 233 // int declared without int myint\\n\\n                        // JUST WORKS\\n                        </pre>\\n<br>\\n<br>\\n                        <blockquote>Batteries Included</blockquote>\\n                        <p>\\n    \\nGo feels minimalistic, but at the same time, maintains all of the essentials necessary for your average tasks in the standard library out of the box. There's no object oriented programming (structures in Go seems to feel much more like objects, since you can now define functions on structs without a lot of function pointer magic). Without needing any external frameworks or packages, we were able to get our web application off the ground, using the packages included with the go distribution, and in comparison to the other languages of a similar structure and type, Go's standard library feels much more developed (while it might shirk the minimalism requirements of C, the value that's provided is endless). You get predefined data types that just aren't present in C, things like slices and maps, which are essentially python lists and dictionaries, <br><br><small>(and hey, MAPS ARE A BUILT IN TYPE, YOU DONT NEED TO READ A PAPER ON SIMPLE UNIFORM HASHING ASSUMPTIONS TO GET PYTHON DICT STYLE KEY VALUE PAIRS)</small><br><br>\\n                        </p>\\n                        <br>\\n                        <blockquote>But there's also one really aggravating thing that's made development difficult\\n</blockquote>\\n                        <br>\\n                        <p>\\n                        In python, modules are simple individual source files, and packages are collections of those files.\\",
            "date": "8/16/15",
            "shortname": "golang-rules",
            "img_link": "../img/img9.png",
            "title": "Golang: Our first look"
        },
        {
            "author": "Kirt Gittens",
            "date": "7/28/15",
            "shortname": "gitflow-problems",
            "title": "The Gitflow Problem",
            "post": "<p>  \nCode dependency hell is a dark place, strewn with the fragmented past of your old code and closed PR's. It's the nigtmare that version control attempts to shield us from, but ultimately the place we all end up during some point in the release cycle. How do you develop related software features in such a way that keeps them isolated and independent, so that they can all be seperately reviewed and merged into a central upstream repository? This is the problem of your software team's git flow. \n</p>\n                        <br>\n                        <br>\n                        <p>\n                            For a while, we had a solution that seemed like it worked. Which was ultimately: don't. We waited for everyone to be finished with development until opening one massive PR to the upstream repository that took most of the week to review and merge appropriately, and in the meantime, any bugfixes that needed to go in, sat around in various states of readiness until the upstream was in. We had one master branch, and merged all of the code there, and from there we made the PR's. Anything that needed to go into our local repository or server, had to wait until upstream was clear.\n                            </p>\n                        <br>\n                        <p>\nThis was ultimately unsustainable. The upstream PR's became bloated and difficult to even understand (try asking someone to review 700+ lines of code at one time, they'll probably laugh at you and then never speak to you again), but aside from that, this put a full stop on development while the PR was open. Having a local repository shoud mean you have the ability to leverage continous integration in an environment you, as the developer, can control. Without it, it's difficult to safely move forward with development. \n                        </p>\n                        <br>\n                        <blockquote><b>*slams on table*</b><br>\nSo, There has to be a better way</blockquote>\n                        <br>\n                        <p>\nSimple solution! Create an upstream branch. We started merging all of our development branches into one master development branch, and then from there, some automated jobs got run in order to check tests and validate the work, and then it can go into the upstream branch. Development was able continue on the local repository, without affecting the upstream PR's that need to be open.</p>\n                        <br>\n<p>\n                        Except that they still ended up being gigantic because we created an artificial code cutoff for what goes into upstream. All of the work that's going up still needs to be in one place at one time (bye bye continuous delivery). We needed to use git and github in such a way that complements the agile development practices. We needed to be able to rapidly deliver small pieces of work.\n</p>\n<br>\n                        <blockquote><b>*slams on table*</b><br>\nSo, There has to be a better way</blockquote>\n                        <br>                        <br>\n                        <p>\nI'll be honest, when I first heard about using git this way, my brain was doing everything in it's power to convince me why it was a terrible idea. But I was incredibly wrong. It's not.\n                        </p>\n                        <br>\n                        <img src=\"../img/spec1.png\" class=\"img-responsive\" style=\"text-align:center; margin: 0 auto;\">\n                        <br>\n                        <p>\n                            Never make PR's from a central location, you need to be able to deliver code whenever it's ready. The system is simple. Work on the development branch, and merge into the local repository, then build it, test it, do the magic that needs to be done. and the re open a PR, directly from devlopment branches to the upstream repository. This allows small, isolated pieces of code to move foward, without causing issues for any other unrelated development tasks. This method runs in to issues if the pieces of work you have are not truly either small or isolated, but the pressure from that issue can be mitigated outside of source control.\n\n                        </p>\n                        <br>\n                        <p>\n                        This method seems to work for us, but ultimately there's an infinite number of ways to use git, and some of those are heavily dependent on the situation. (Although, if you're dutch, please inform me of the best git flow? thanks.) Regardless of that, I think your source control methods need to fit the way in which you want to deliver software.\n\n                        </p>",
            "img_link": "../img/img8.png"
        },
        {
            "title": "DONT TEACH YOUR KID SCRATCH",
            "date": "6/28/15",
            "author": "Kirt Gittens",
            "post": "<blockquote>\n                        DONT TEACH YOUR KIDS SCRATCH\n                        </blockquote>\n<p>  \nI should probably make this abundantly clear first, I am, in no way claiming that you should not teach your kids how to program. I think in some cases it is the best thing you can do; showing your kid how they can express creativity through building with code. Being taught to code as a child reason why I'm a programmer and love programming so much (thanks mom, code also ruined my life though, so there's that), but what I DO think is really important is NOT underestimating your childs ability to learn.\n</p>\n                        <br>\n                        <br>\n                        <p>\n                            I remember as a 11 or 12 year old, my mother gifting me as a present, a large scary looking collection of Visual Basic 6 books, when I told her I wanted to learn \"how to make video games\". Even as an adult, I'll admit, those things are pretty frightening looking (GUYS AT MSDN, CAN YOU PLEAASE UPDATE YOUR UX FROM WHAT IT LOOKED LIKE IN 2001? IT WOULD HAVE MADE MY CHILDHOOD LESS SCARY THANKS), but as a kid, when you're able to focus on, and visualize the thing that you want to make, you can pull out the pieces of information that you need, in order to create whatever is in your mind. Your brain is a lot more malleable then, in contrast to how your brain works when you get older, so I think you can actually learn a lot more faster, (your brain still operates under the premise of 'oh, that's just how that works?'). \n                            </p>\n                        <br>\n                        <p>\nIn the recent years, there's been a huge push to teach kids to code. Movements like Hour of Code, Projects like Tynker, and then there's the specifially \"built for education\" programming tools like Scratch and Grace.\n                        </p>\n                        <br>\n                        <p>\n                        I kind of think these sorts of things, don't excatly account for the intelligence of kids. \n                        </p>\n                        <br>\n                        <p>\n                           Scratch seeks to introduce kids to programming from a user friendly drag and drop interface that essentially lets them drop code structure elements into a visual \"program\", and while its completely visual and mightbe  much easier to parse for kids, I think it actually stops short of teaching them a real skill, and it seems like its more of a teaching tool for abstract and conceptually thinking more than anything else. It might not be dumbing down the problem (you could argue that the skills carry over, like with any real programming language), except that as a kid, I don't think that's what you'll remember.\n                        </p>\n                        <br>\n                        <p>I had a recent talk with a 10 year old relative of mine, about his Lego Robotics NXT class, where he informed me that they were learning a language called ROBOT C, as a kind of introduction to programming and logic concepts. Upon looking at the syntax however, it's just REAL C. He was able to identify the parts of a standard C program in the same way that he might as a part of the building blocks of learning full fledged software development\n</p>\n                        <br>\n                        <br>\n                        <p>\n                        I think the teaching tool here is actually the goal they want to accomplish rather than the way the information is presented. Moving a real physical robot around and having it perform tasks is the part that simplifies the concepts. \nPresenting something visual (tat's whats of interest to the kids) moves the problem domain into something they care about an understand, but the skill that they walk away with, is real and practical.\n\n                        </p>",
            "img_link": "../img/img7.png",
            "shortname": "scratch-programming"
        },
        {
            "shortname": "what-would-linus-do",
            "post": "<blockquote>\n                        \"And that means that for a while that feature will be very very broken, right? Because nobody actually creates perfect code the first time around, except me, but there is only one of me, right? \" ~Linus\n                        </blockquote>\n<p>  \nI've always chosen to look at this, not just as your typical statement of baseless superiority (and, because of who it's coming from, it's not EXACTLY basless), but more of a starting point of aspiration for developers.  The pinnacle of attainment for any software developer, to move from the realm of the mere mortal, running and re-running his unit tests, making the requested review changes on his PR, even after meticulous self review and scrutiny, to the house of the gods, where code \"just works\".\n</p>\n                        <br>\n                        <br>\n                        <p>\n                            You want your kernel pactches to never be questioned, your pull requests to go in without comment, and to miss nothing when you commit code, because \"that's just the way you write code\". Why do we have the process (tests, review, and re-review) to ensure correctness, when it's our job as developers to ensure correctness from the very beginning? Linus might be right, maybe all of us are terrible developers for relying on the process to validate our code, and continuous integration is crutch software to make up for our shortcomings in the area of reliable code. Considering any untested lines of code, as a bug simply means that you don't trust your programmers, right?\n                            </p>\n                        <br>\n                        <br>\n                        <blockquote>Maybe, or maybe not, I think the truth is:\n</blockquote>\n                        <br>\n                        <p>\n                            We test to ensure the stability of the product, not to undermine the correctness of the developer. A software product is more than the individual developers that write code for it, and that's not to exuse the mistakes that developers make, but (#1 everyone makes them), so testing raises the question of whether you want bugs to be found by your users or you. (I hope that's an easy question to answer). As your codebase scales to a ceratin point, and because huge and interdependent upon internal functionality, code changes you make are going to rely on appropriate integration testing to control the damage (hey, you heard that expression anywhere ever before?). As you reach a certain point of scale, it becomes really easy to lose sight of what change are going to affect what other code. \n                        </p>\n                        <br>\n                        <br>\n                        <p>\n                            So, maybe this isn't something that is worth saying to web developers, (I could probably pull up 8000 articles about the benefits of automated test suites in our particular realm of development) but I always get shamed whenever I try and have this conversation with anyone from the linux kernel side of things. And while we all write code, maybe the methods of development actually DO differ from use case to use case (despite the things I am told ALL the time about python and web dev).\n\n                        \n                        </p>\n                        <br>\n                        <br>\n                        <p>Software is about delivering a product, and in order to ensure the stability of that product, you might have to sacrifice some of the (really agressive) ways in which you view development.\n</p>\n                        <br>",
            "img_link": "../img/img6.png",
            "author": "Kirt Gittens",
            "date": "6/17/15",
            "title": "What Would Linus Say?"
        },
        {
            "author": "Kirt Gittens",
            "date": "5/28/15",
            "title": "3 DEFINITIVE WAYS TO MAKE YOUR PYTHON API BETTER",
            "shortname": "meta-class-python",
            "post": "<p>\n                       \nI've seen python libraries lately that could use some tips on the API design. The ideas behind a lot of these developer API's are solid, but the code just doesn't quite feel as strong as it could, so here's a few pointers on how to make every API you write (objectively) better! . \n</p>\n                        <br>\n                        <blockquote>\n                                1. USE METACLASSES (IN EVERYTHING)\n                        </blockquote>\n                        <br>\n<p>\n\t\tScrew Tim Peters, you need metaclasses in everything! It doesn't matter if you could have done it another way without adding complexity for the end users, You wanna be in that special 1% of programmers right? So you'd better use a metaclass. When people can't figure out what your code does by looking at it, you want to be able to laugh condescendingly and tell them \"it's magic\" without explaining anything. If they we're REAL python developers they'd understand.\n</p>\n                        <br>\n                        \n                          <blockquote>\n                                2. OVERRIDE PYTHON BUILTINS\n                        </blockquote>\n                        <p>\n\t\tWhat did getattr do? who cares it was probably dumb. Re-Write it! make your code do something random every time you call setattr or getattr. This is how you write magic code! Python core clearly doesn't support your super specific use case so make it work for you! You should be contributing to the core, forget what Raymond may have said!\n                            </p>\n<blockquote>\n                        3. PROGRAM FUNCTIONALLY\n\n                        </blockquote>\n                            <p>\tYou wanna be a better programmer? Write code that goes against the paradigm of your own programming language that will inevitably make you want to kill yourself!\n<br>\n                                </p>\n<blockquote><i>okay okay you got me, I'm done</i></blockquote> <br>\n\n                        <p>\nokay okay I'm done, but seriously there's something to be said for doing your best to reduce complexity for both the end developer and in the API/framework itself. Sure you want do to things as efficient as possible. Use whatever tools the language gives you to the extent that they facilitate something that would otherwise be tedious or cumbersome. But I'd challenge developers to take a reductive use approach instead of attempting to apply the advanced features of the language wherever you can. Don't un-necessarily obsfucate anything. One of the amazing things about python as a language is how stupidly easy it is to read and understand (in comparison to seeing 8 million function templates and ```typdef struct``` 's ') so just because you can think of a use case for something, doesn't always mean that it'll make your code better or even more importantly, more beautiful. That's not to say there aren't definitive places where using descriptors and metaclasses turn out to be the best option, but I think upon deeper investigation, the actual amount of such places is unbelivably few.\n                            </p>\n                        <br>\n<p>\nI think keeping the principle of maintaining beautiful code should extend down to your API as well. The ease with which a new developer can interpret and get understanding about what you've written, is a good thing, not a bad thing!\n</p>\n                        <br>\n                        <p>\nBut maybe I'm wrong. You should probably only use python in the bios for CFFI extensions written in Rust, right?\n<br>\n<br>\n\n",
            "img_link": "../img/img5.png"
            
        },
        {
            "author": "Kirt Gittens",
            "title": "Those Django Forms Sat Me Down",
            "date": "4/25/15",
            "img_link": "../img/img4.png",
            "shortname": "django-forms-sat-me-down",
            "post": "<p>\n                        So, Django got in my way earlier this week. And that's unusual, because Django is generally awesome! It's one of the most robust web frameworks I've ever seen, that manages to ship with batteries-included, and at the same time, remains simplistic without feeling bloated (<b>RAILS</b>). If you care about Python at all and haven't checked it out (the chances of this being the case should be NEARLY non-existent) definitely do so <a href = \"https://code.djangoproject.com/\">[Django Link]</a>. \n</p>\n                        <br>\n                        <blockquote>\n<i>But back to the grumbling</i>\n</blockquote>\n                        <br>\n<p>\n\tDjango's Forms API abstracts away the work of validating a ton of related user input fields that you need to use in your application. This works great in the basic use case. Lets say you need to grab some information from a user. Works Fine:\n</p>\n<pre class = \"brocode\">\nclass DamageControlCommentForm(forms.Form):\n\t\tname_field = Fields.ImaginaryNameField()\n\t\tcomment_field = Fields.InTheTrashField()\n</pre>\n                        <br>\n                        <p>\n\tThe criteria for validating your form is generally already taken care of for you with django's validation API, so all you have to do is define the criteria, like so:\n</p>\n                        <pre class = \"brocode\">\nclass DamageControlCommentForm(forms.Form):\n    article_metacritic_score = Fields.IntegerField(\n        min_value = 90 #out of 100\n    )\n</pre>\n                        <br>\n                        <p>\n\tAnd Django will take care of the work of validating the input based on the criteria you set here in the field instantiation. When you attempt to supply a value to this Form that's smaller than 90, It should throw an error that you can display in your HTML. \n                            \n                            <p>It appears to work for the smaller use cases, but as your forms get larger and more complicated, and start having more complex validation requirements, you'll start running into some issues. What if I write a huge and complicated form that I don't want to have to duplicate, but need use with some slightly different validation criteria. Shouldn't I be able to just subclass the form and just change some things? Most people will try and tell you that you can! (but you can't REALLY). Let's try subclassing our form and then JUST changing some of the validation rules we need.\n                                </p>\n</p>\n<pre class = \"brocode\">\n#Let's assume DamageControlCommentForm has a TON of stuff in it now\n# and I need to use basically the same form\n# but with a few different validation attributes\n\nclass DamageControlPythonArticleComment(DamageControlCommentForm)\n    def __init__(self, *args, **kwargs):\n        super(DamageControlPythonArticleComment, self).__init__(*args, **kwargs)\n        self.fields['article_metacritic_score'].min_value = 100 \n        # Python is WAY cooler than anything else (ruby  == garbage)\n</pre>\n\n                        <p>\n\tThis looks like it should work, but it doesn't. When you instantiate this form, and attempt to pass a max_value of 90, it WON'T throw the error like it should according to your new validation criteria for <i>DamageControlPythonArticleComment</i>. And the reason why actually isn't very well documented, you'll have to kind of dig in to the source code of django to figure it out. The code that gets run when we instantiate an IntegerField field in Django looks like this.\n</p>\n\n                        <br>\n<pre class = \"brocode\">\ndef __init__(self, max_value=None, min_value=None, *args, **kwargs):\n    self.max_value, self.min_value = max_value, min_value\n    if kwargs.get('localize') and self.widget == NumberInput:\n        # Localized number input is not well supported on most browsers\n        kwargs.setdefault('widget', super(IntegerField, self).widget)\n    super(IntegerField, self).__init__(*args, **kwargs)\n\n    # THESE LINES ARE THE PROBLEM\n    if max_value is not None:\n        self.validators.append(validators.MaxValueValidator(max_value))\n    if min_value is not None:\n        self.validators.append(validators.MinValueValidator(min_value))\n</pre>\n                        <br>\n<p>\n\tAs you can see, Django uses Validator objects, and evaluates them based on the field attributes that you set UPON INSTANTIATION. It basically side-steps the problem of having to write a bunch of redundant code in each of the validate methods for your field. It's a smart design if you never need to change validated attributes of a field. But if you do? the changes you make won't be reflected in the validators (it's an array that we never REALLY remove from) and the whole point of that nice subclassing and attribute changing is gone. For each field, we have a self.validators array, which we iterate through every time we call validate/clean(), and check for any errors. This WOULD be fine, except that django currenctly doesn't handle updating or clearing that array, so even if you make changes, the values set in __init__ stay there for the life of your field.\n</p>\n\n<p>\n\tThere's some things YOU can do to get around this problem, \n                            <blockquote>but most of them are gross, like this:</blockquote>\n</p>\n      \n<pre class = \"brocode\">\t\nclass ProxyIntegerField(IntegerField):\n    \"\"\"\n        This is gross and not DRY, i don't like it\n    \"\"\"\n    def __init__(self):\n        super(ProxyIntegerField, self)\n        del self.validators[:]\n\n    def validate(self, value):\n        if value > self.max_value or value &lt; self.min_value: \n            raise ValidatorError(\"you messed up bro\")\n</pre>\n                <br>\n                <p>\n\tSure you CAN get rid of validators and force the logic into your validate function, except that this is redundant, and trying to do the same thing as django validators. You'll have both approaches in your code and the whole solution isn't really reusable.\n</p>\n                <br>\n                <p>\n\tYou could do this too:\n                    </p>\n<pre class = \"brocode\">\nclass DamageControlPythonArticleComment(DamageControlCommentForm):\n    def __init__(self, *args, **kwargs):\n        super(DamageControlPythonArticleComment, self).__init__(*args, **kwargs)\n\n    article_metacritic_score = Fields.IntegerField(\n        min_value = 100 #top lel, writing the same code over again\n    )\n</pre>\n                <br></br>\n<p>\n    Some might see this as a solution to the problem, and sure, it works. But as the Form you're working with grows larger and more complex, solving the issue this way becomes less feasable as you may need to change more fields. In a case where you.. say had 15 fields that you simply needed to update the max value on, It'd be nice to just iterate over a list of the field names instead of re-writing 15 different field definitions with the only difference being a single attribute.\n</p>\n            <br>\n<p>\nYou could argue that the use case is esoteric, or that we're trying to do something that doesn't make sense in the first case (instance level manipulation of a form field). But this applies to ANY time you need dynamic validation attributes for a form that you don't want to write into your validate() method.\n            </p>\n            \n            <br>\n        \n            <p>\n    I personally think that Django should handle this problem, because there's an easy solution that fits ALL of these kind of dynamic update cases, but making it efficient might require some larger design changes. \n                </p>\n            \n            <p>The short version of the fix essentially looks like this: </p>\n            \n<pre class = \"brocode\">\n# within some base field or In django.forms.fields.py\n@property\ndef update_max_value(self):\n    return self.max_value\n    \n@update_max_value.setter\ndef update_max_value(self, value):\n        validator = [validator for validator in self.validators\n                     if isinstance(validator, MaxValueValidator)].pop()\n        self.validators[self.validators.index(validator)].limit_value = value\n</pre>\n            \n            <p>This would be even simpler looking if field.validators was a dictionary. But I personally think it gets the job done. But I don't know, maybe this is horrible and you should never even need to do this anyway. Who knows?  </p>\n                    \n<br>\n\t<blockquote>(also interesting note. if you deepcopy() a form field it clears the validators..)</blockquote>"
        },
        {
            "author": "Lonny Wortham",
            "title": "Worst Programming Language",
            "date": "2/12/15",
            "img_link": "../img/test.png",
            "post":"<strong>What is the worst programming language ever created?</strong>\n                            <br><br>\n                        <p>\nI've approached some of the most socially inept and conversation-challenged programmers to ever walk the face of this earth with this question as my opening line. Which has resulted in conversations(borderline fist-fights), that I was not mentally (or physically) prepared to have.\n</p>\n                        <p>\nThe common answers are PHP, because of its naming conventions, or Perl because of how it's a massive mess on paper, or Lotus-script because of every single damn aspect of it. \n                        </p>\n<b>Less common answers trigger the true horror. </b>\n                        <br>\n                        \n                        <br>\n <p>\nBancStar, a language for banking systems, is a demonically temperamental monstrosity of a language with over 3000 predefined variables. Additionally its subroutines can be corrupted by a click of anyone of a client's function keys.\n </p>\n                        <p>\nLabTalk, the maximum length of a string variable is one character.\nNo, you didn't misread that. One character. Are you counting your ASCII keys? Don't bother. The creators didn't think you needed that many.\n                            </p>\n <br>\nAn excerpt from the programming manual:\n <br>\n                        <br>\n                    <blockquote>\nLabTalk uses the % notation to define a string variable. A legal string variable name must be a % character followed by a single alphabetic character (a letter from A to Z). String variable names are not case sensitive. Of all the 26 string variables that exist, Origin itself uses 14.\n </blockquote>\n                        <br>\n                        <b>You couldn't code pong</b>\n <br>\n                        <p>\nOkay so yes. PHP is all over the place when it comes to naming. and Perl doesn't make for the prettiest code. And Labtalk sounds like a programming language used by the NSA...\n <br>\n...as a form of torture once water-boarding became passe. \n <br>\n<br>\nI freely grant my foes all of this. So how, or rather why, does the brawl begin? It's because I don't have anything against the unwanted stepchildren of programming.\n \nIt's because of my disgust towards the poster child of the inter-webs.\n \nIt's because I REALLY hate JavaScript. \n \nIs it as bad as LabTalk? Probably not. But I don't have to use LabTalk do I? I have it on good authority that I will never have to make use of that ridiculous excuse of a language. \n \nJavaScript though...\n \nI will never understand how this piece of trash became one of the most widely known and beloved scripting languages. \n \nSure, it's easy. Yes, the syntax is clear and concise. Fine, there are a ton of awesome libraries and frameworks supporting it...\n \nOkay. Granted, JavaScript has some pretty kick-butt features. But I will never ever have warm cuddly feelings toward it. NEVER. \n </p>\n                        <br>\n                        \n<strong><i>\"Why?\"</i> you may wonder.</strong>\n <br>\n                        <br>\n                        <p>\nI'll tell you.\n \nFirst off. Have you ever worked with jQuery? Yes? Then you'll know exactly what I'm talking about.\n \nWhy isn't that a language?\n \nWhy do we even still have JavaScript? We see how grossly inefficient its syntax is. I don't care how readable it happens to be. The less character's I have to type the more I get done.\n \nMy second reason is a bit weightier:\n \nI'm a pretty decent programmer. \n \nI think things through the way a programmer should. I write out detailed workflows and I make sure my pseudo-code is in order.\n \nWhen I sit down at my computer with a bottle of cherry Coca-cola zero and variously flavored Slimjims I'm ready to knock out an application, or a website, or a program, and I'm determined that it should only take a few hours. \n \nI turn on some EDM or classical music, depending on my mood and I get to work. I'm really on a roll; things are shaping up nicely. I'm already patting myself on the back for being such a fast and efficient programmer. Then it happens. IT ALWAYS HAPPENS. \n  <br><br>\nMe: \"Hey JavaScript. I just want to spread a canvas over the entire documentBodyHeight. You got something built in for that?\"\n  <br><br>\nJavaScript: \"Well...no. No I don't; canvas can't be set to 100%\"\n  <br><br>\nMe: \"Oh... okay. That's really too bad. Well can I get the documentBodyHeight in pixels?\"\n  <br><br>\nJavaScript: \"Well...yes. But it's a bit of a secret. I won't just tell you. You'll have to figure something out.\"\n  <br><br>\nMe: (an hour later) \"Okay so I inserted a div and set its z-index super high and set its height to 100% now can I get the height of the div and thus the height of the document using bodyScrollHeight?\"\n \nJavaScript: \"Sure thing. In Chrome. If you're looking for something that works on most all Browsers then I suggest using...well no I guess you're stuck with me.\"\n \nMe: (four hours later) \"So I took the measurement of innerWindow height and used the ternary operator to combine it with window offset height, did the same with width and should now have the dimensions of the page. How's that?\"\n  <br><br>\nJavaScript: \"Wow. First time I've seen code that only works in IE 8.\"\n  <br><br>\nIt is at this point in the conversation that I probably fall into a Slimjim and diet coke induced coma.\n  <br><br>\nIn case you've completely missed the purpose behind my crazed discourse with the anthropomorphized JavaScript language; I'll spell it out.\n  <br><br>\nIn spite of the humongous amount of documentation, the tremendous support of stellar frameworks, and a massive demand for the language, JavaScript still lacks the ability to provide coherent and reasonable means to complete simple tasks. \n  <br><br>\nI don't want to waste hours figuring out simple procedures that THE LANGUAGE WAS DESIGNED SPECIFICALLY TO COMPLETE. \n  <br><br>\nYou can create a canvas element in html. JavaScript is supposed to facilitate my interaction with that object. Sure it does its job, 90% of the time. But the other 10% it requires the worst kind of problem solving, trial and error. \n  <br><br>\nIf JavaScript were a cheese then it'd be Swiss. If it were a pan it'd be a colander.\nHow can a language be designed so specifically for one thing, yet still leave such irritating, glaring holes?  \n <br><br>\nAND WHY DOES EVERYONE ACT AS IF THEY DON'T EXIST?!? As if JavaScript is some sort of promised land of front end programming.  Trust me, until we can adequately manipulate every aspect of basic DOM elements we remain wandering in the wilderness. JavaScript is, at its best, the water that sustains us, barely.\n                            </p>",
            "shortname": "worst-programming-language"
        }
    ]
}